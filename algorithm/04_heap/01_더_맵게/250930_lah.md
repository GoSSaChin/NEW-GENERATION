[![PRO]][Link]

## 문제 해석

- 주어진 스코빌 지수의 특별한 계산 방법으로 K를 넘길 때까지의 조합 개수

## 최종 제출 코드

- class로 최소힙 구현에 필요한 메서드 정의

```js
class MinHeap {
  // heap 초기화
  constructor() {
    this.heap = [];
  }
  // 주어진 인덱스의 부모 노드 인덱스 계산
  getParentIndex(i) {
    return Math.floor((i - 1) / 2);
  }
  // 주어진 인덱스의 왼쪽 자식 노드 인덱스 계산
  getLeftChildIndex(i) {
    return i * 2 + 1;
  }
  // 주어진 인덱스의 오른쪽 자식 노드 인덱스 계산
  getRightChildIndex(i) {
    return i * 2 + 2;
  }
  // 두 노드 값을 교환
  swap(i1, i2) {
    [this.heap[i1], this.heap[i2]] = [this.heap[i2], this.heap[i1]];
  }
  // 새로운 요소를 힙에 삽입
  push(value) {
    this.heap.push(value);
    this.heapifyUp();
  }
  // 삽입 후 힙 조건 복구
  heapifyUp() {
    let index = this.heap.length - 1;
    while (
      this.getParentIndex(index) >= 0 &&
      this.heap[this.getParentIndex(index)] > this.heap[index]
    ) {
      this.swap(index, this.getParentIndex(index));
      index = this.getParentIndex(index);
    }
  }
  // 최소값(root) 꺼내기
  pop() {
    if (this.heap.length === 1) return this.heap.pop();
    const root = this.heap[0];
    this.heap[0] = this.heap.pop();
    this.heapifyDown();
    return root;
  }

  // 꺼낸 후 힙 조건 복구
  heapifyDown() {
    let index = 0;
    while (this.getLeftChildIndex(index) < this.heap.length) {
      let smallerChildIndex = this.getLeftChildIndex(index);
      if (
        this.getRightChildIndex(index) < this.heap.length &&
        this.heap[this.getRightChildIndex(index)] < this.heap[smallerChildIndex]
      ) {
        smallerChildIndex = this.getRightChildIndex(index);
      }
      if (this.heap[index] < this.heap[smallerChildIndex]) break;
      this.swap(index, smallerChildIndex);
      index = smallerChildIndex;
    }
  }

  size() {
    return this.heap.length;
  }
  peek() {
    return this.heap[0];
  }
}

function solution(scoville, K) {
  const heap = new MinHeap();
  scoville.forEach((s) => heap.push(s));

  let count = 0;
  while (heap.peek() < K && heap.size() > 1) {
    const first = heap.pop();
    const second = heap.pop();

    heap.push(first + second * 2);
    count++;
  }

  return heap.peek() >= K ? count : -1;
}

//     let count = 0;
//     let score = 0;

//     while (true) {
//         scoville.sort((a, b) => a - b)
//         score = scoville[0] + scoville[1] * 2

//         if (score > K) {
//             break
//         } else {
//             count += 1
//             scoville.filter((e) => e !== scoville[0])
//             scoville.filter((e) => e !== scoville[1])
//         }
//     }

//     return count;
```

## 시간 복잡도

- **∴ O(N log N)**

## 메모

- 힙 : 제일 위에 부모(루트) 하나가 있고, 그 아래로 자식 노드들이 달려 있는 구조
- 최소 힙 : 가장 작은 값이 항상 맨 위(루트)에 있는 트리 (위로 갈수록 값이 작고, 아래로 갈수록 값이 커진다는 규칙) >>> 가장 작은 값은 항상 맨 위 / 삽입 삭제가 빠름
- 장점
  - 보통 배열에서 가장 작은 값을 찾으려면 전부 뒤져야해서 O(N)의 시간이 걸림
  - 최소 힙에서는 맨 위(루트)만 보면 되니까 O(1)의 시간이 걸림
  - 새로운 값을 넣거나 빼도, 부모-자식 자리만 바꿔주면 되기 때문에 O(log N)으로 금방 끝남
- 배열에서의 표현
  - 왼쪽 자식 : 2 \* i + 1
  - 오른쪽 자식 : 2 \* i + 2
  - 부모 : (i - 1) / 2 (내림)

<!---------------------------------------------------------------------------->

[PRO]: https://github.com/GoSSaChin/algorithm-js/assets/107768516/67c43b52-bc3f-4571-a249-5519021afbb0
[Link]: https://school.programmers.co.kr/learn/courses/30/lessons/42626
