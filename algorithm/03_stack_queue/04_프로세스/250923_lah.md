[![PRO]][Link]

## 문제 해석

- 초 단위의 주식가격이 배열로 주어졌을 때, 각 인덱스의 주식 가격은 몇 초 동안 유지되었는지 반환

## 최종 제출 코드

- 인덱스 사용 : 초를 계산하는 것
- `stack` : 마지막 값과 루프를 도는 값을 비교하여서 가격이 떨어진 경우를 파악하기 위함
- 가격이 유지되는 값은 `stack`에 추가, 가격이 떨어진 경우에는 `answer`에 기록
-

```js
function solution(prices) {
  // [1, 2, 3, 2, 3]
  const answer = new Array(prices.length).fill(0); // 결과 배열
  const stack = []; // 스택 초기화

  for (let i = 0; i < prices.length; i++) {
    // 스택이 비어있지 않고 현재 가격이 스택의 마지막 가격보다 낮을 때
    while (stack.length && prices[stack[stack.length - 1]] > prices[i]) {
      const idx = stack.pop(); // 스택에서 인덱스 꺼내기
      answer[idx] = i - idx; // 현재 인덱스와 스택에서 꺼낸 인덱스의 차이
    }
    stack.push(i); // 현재 인덱스 추가
  }

  // 스택에 남아 있는 인덱스는 끝까지 가격이 떨어지지 않고 유지된 것
  while (stack.length) {
    const idx = stack.pop();
    answer[idx] = prices.length - 1 - idx; // 남은 인덱스에 대해 마지막 가격까지의 차이
  }

  return answer;
}
```

## 시간 복잡도

- **∴ O(n)**

## 메모

- 가격이 떨어지는 시점을 찾기위해 `stack`을 사용 (마지막 값을 `pop`해서 사용할 수 있기 때문)

<!---------------------------------------------------------------------------->

[PRO]: https://github.com/GoSSaChin/algorithm-js/assets/107768516/67c43b52-bc3f-4571-a249-5519021afbb0
[Link]: https://school.programmers.co.kr/learn/courses/30/lessons/42587
