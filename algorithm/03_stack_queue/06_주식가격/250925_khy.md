[![PRO]][Link]

## 문제 해석

-  초 당 주식 가격이 주어졌을 때, 해당 시간의 가격이 몇 초동안 떨어지지 않았는지 저장
-  stack에 가격이 떨어지지 않은 시점들을 저장, 마지막 원소의 가격과 현재 가격을 비교해 유지된 시간을 계산

## 최종 제출 코드

-  가격이 몇 초동안 떨어지지 않았는지 저장할 배열 `answer`을 정의합니다.
   -  `answer`의 인덱스: 시점 (초 단위)
-  스택 배열(`stack`)에는 가격이 떨어지지 않은 시점들을 저장합니다.
-  0초 시점부터 마지막 시점까지 순회하며 `stack`에 저장된 마지막 시점(`top`)과 현재 가격을 비교합니다.
   - 만약 현재 가격이 더 떨어졌다면 `top` 시점의 가격이 유지된 시간을 계산해 저장합니다.
   - 가격이 유지된 시간: `top` - 현재 시점(`i`) 
-  순회가 끝난 후에도 `stack`에 저장된 시점, 즉 마지막까지 가격이 떨어지지 않은 시점을 별도로 처리합니다.
   - 가격이 유지된 시간: 마지막 시점(`n - 1`) - `top` 
-  `answer`을 반환합니다.

```js
function solution(prices) {
    const n = prices.length;
    const answer = new Array(n).fill(0);
    const stack = [];

    for (let i = 0; i < n; i++) {
        while (stack.length && prices[i] < prices[stack.at(-1)]) {
            const top = stack.pop();
            answer[top] = i - top;
        }
        stack.push(i);
    }

    while (stack.length) {
        const top = stack.pop();
        answer[top] = n - 1 - top;
    }

    return answer;
}

```

## 시간 복잡도

- n: `prices`의 길이
- `for`문 안에서 `stack.pop()`을 최대 n번 실행: O(n) 
- **∴ O(n)**


<!---------------------------------------------------------------------------->

[PRO]: https://github.com/GoSSaChin/algorithm-js/assets/107768516/67c43b52-bc3f-4571-a249-5519021afbb0
[Link]: https://school.programmers.co.kr/learn/courses/30/lessons/42584