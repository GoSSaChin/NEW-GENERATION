[![PRO]][Link]

## 문제 해석

-  작업 진도와 속도가 주어졌을 때 한 배포 당 몇 개의 기능이 배포되는 지 반환


## 최종 제출 코드

-  한 번에 배포하는 기능의 수를 저장하는 빈 배열 `ans`를 만듭니다.
-  대기 중인 작업 중 가장 앞에 있는 작업을 기준 작업으로 설정합니다. (한 번에 배포되는 기능의 숫자 `cnt`와 작업에 걸리는 날짜 `days`를 계산)
-  기준 작업과 현재 작업의 진도를 비교하며 다음 과정을 반복합니다.
    - 만약 현재 작업이 더 빨리 끝나는 작업이라면 `cnt`를 1 증가시키고 다음 작업을 탐색합니다.
    - 만약 현재 작업이 더 늦게 끝나는 작업이라면 `cnt`를 `ans`에 `push`하고 반복을 마칩니다. (현재 작업을 기준 작업으로 설정)
- 위 과정이 끝난 후  `ans`를 반환합니다.

```js
function solution(progresses, speeds) {
    let [i, ans] = [0, []];
    while (i < progresses.length) {
        let [cnt, days] = [0, Math.ceil((100 - progresses[i]) / speeds[i])];
        while (
            i < progresses.length &&
            progresses[i] + speeds[i] * days >= 100
        ) {
            i++;
            cnt++;
        }
        ans.push(cnt);
    }
    return ans;
}
```

## 시간 복잡도

- n: `progresses`의 길이
- 이중 `while` 문에서 실제로 반복되는 횟수는 `n`: O(n)
- **∴ O(n)**


<!---------------------------------------------------------------------------->

[PRO]: https://github.com/GoSSaChin/algorithm-js/assets/107768516/67c43b52-bc3f-4571-a249-5519021afbb0
[Link]: https://school.programmers.co.kr/learn/courses/30/lessons/42586
