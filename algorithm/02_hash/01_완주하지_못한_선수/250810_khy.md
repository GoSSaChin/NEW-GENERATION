[![PRO]][Link]

## 문제 해석

-  완주하지 못한 선수 1명을 반환
-  배열 두 개를 비교해 일치하지 않는 원소를 반환 > 원소 찾기 > `Map` 사용
-  `Set` 대신 `Map`을 사용하는 이유: 동명이인이 존재하기 때문에 같은 이름의 참여자 수도 함께 저장해야 함

## 최종 제출 코드

-  `completion`을 순회하며 `Map` 객체(`map`)에 완주자의 이름과 그 수를 key-value 형태로 저장합니다.
-  `participant`을 순회하며 `map`에 값이 존재하지 않거나 값이 0인 경우 참가자를 즉시 반환합니다.

```js
function solution(participant, completion) {
    const map = new Map();
    for (let i = 0; i < completion.length; i++) {
        map.set(completion[i], map.has(completion[i]) ? map.get(completion[i]) + 1 : 1);
    }
    
    for (let j = 0; j < participant.length; j++) {
        if (!map.get(participant[j])) return participant[j];
        map.set(participant[j], map.get(participant[j]) - 1);
    }
}
```

## 시간 복잡도

- n: `participant`의 길이
- `map`에 완주자를 저장할 때, `map`에서 참가자를 찾을 때 각각 O(n)
- **∴ O(n)**

## 메모

-  문제 조건을 잘 읽어보고 엣지 케이스 생각하기 (ex) 동명이인의 존재 여부)

<!---------------------------------------------------------------------------->

[PRO]: https://github.com/GoSSaChin/algorithm-js/assets/107768516/67c43b52-bc3f-4571-a249-5519021afbb0
[Link]: https://school.programmers.co.kr/learn/courses/30/lessons/42576
